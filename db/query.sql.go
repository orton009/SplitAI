// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addFriend = `-- name: AddFriend :one
INSERT INTO friends (user_id, friend_id) 
VALUES ($1, $2)
ON CONFLICT (user_id, friend_id) DO NOTHING
RETURNING user_id, friend_id, created_at
`

type AddFriendParams struct {
	UserID   uuid.UUID
	FriendID uuid.UUID
}

func (q *Queries) AddFriend(ctx context.Context, arg AddFriendParams) (Friend, error) {
	row := q.db.QueryRowContext(ctx, addFriend, arg.UserID, arg.FriendID)
	var i Friend
	err := row.Scan(&i.UserID, &i.FriendID, &i.CreatedAt)
	return i, err
}

const addUserExpenseMapping = `-- name: AddUserExpenseMapping :one
INSERT INTO expense_mapping (expense_id, user_id)
SELECT $1, $2 
ON CONFLICT DO NOTHING
RETURNING TRUE
`

type AddUserExpenseMappingParams struct {
	ExpenseID uuid.UUID
	UserID    uuid.UUID
}

func (q *Queries) AddUserExpenseMapping(ctx context.Context, arg AddUserExpenseMappingParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, addUserExpenseMapping, arg.ExpenseID, arg.UserID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const addUserInGroup = `-- name: AddUserInGroup :one
INSERT INTO group_members (user_id, group_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
RETURNING TRUE
`

type AddUserInGroupParams struct {
	UserID  uuid.UUID
	GroupID uuid.UUID
}

func (q *Queries) AddUserInGroup(ctx context.Context, arg AddUserInGroupParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, addUserInGroup, arg.UserID, arg.GroupID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const checkUserExistsInGroup = `-- name: CheckUserExistsInGroup :one
SELECT EXISTS(
    SELECT 1 FROM group_members
    WHERE user_id = $1 AND group_id = $2
)
`

type CheckUserExistsInGroupParams struct {
	UserID  uuid.UUID
	GroupID uuid.UUID
}

func (q *Queries) CheckUserExistsInGroup(ctx context.Context, arg CheckUserExistsInGroupParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserExistsInGroup, arg.UserID, arg.GroupID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createOrUpdateExpense = `-- name: CreateOrUpdateExpense :one
INSERT INTO expense (id, description, amount, split, status, settled_by, created_by, payee, created_at, updated_at, group_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
ON CONFLICT (id) DO UPDATE SET
    description = EXCLUDED.description,
    amount = EXCLUDED.amount,
    split = EXCLUDED.split,
    status = EXCLUDED.status,
    settled_by = EXCLUDED.settled_by,
    created_by = EXCLUDED.created_by,
    payee = EXCLUDED.payee,
    updated_at = NOW() AT TIME ZONE 'Asia/Kolkata',
    group_id = EXCLUDED.group_id
RETURNING id, description, amount, split, status, settled_by, created_by, payee, group_id, created_at, updated_at
`

type CreateOrUpdateExpenseParams struct {
	ID          uuid.UUID
	Description sql.NullString
	Amount      string
	Split       json.RawMessage
	Status      string
	SettledBy   uuid.NullUUID
	CreatedBy   uuid.UUID
	Payee       json.RawMessage
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	GroupID     uuid.NullUUID
}

func (q *Queries) CreateOrUpdateExpense(ctx context.Context, arg CreateOrUpdateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, createOrUpdateExpense,
		arg.ID,
		arg.Description,
		arg.Amount,
		arg.Split,
		arg.Status,
		arg.SettledBy,
		arg.CreatedBy,
		arg.Payee,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.GroupID,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Amount,
		&i.Split,
		&i.Status,
		&i.SettledBy,
		&i.CreatedBy,
		&i.Payee,
		&i.GroupID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrUpdateGroup = `-- name: CreateOrUpdateGroup :one
INSERT INTO "group" (id, name, description, admin_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    description = EXCLUDED.description,
    admin_id = EXCLUDED.admin_id
RETURNING id, name, description, admin_id
`

type CreateOrUpdateGroupParams struct {
	ID          uuid.UUID
	Name        string
	Description string
	AdminID     uuid.UUID
}

func (q *Queries) CreateOrUpdateGroup(ctx context.Context, arg CreateOrUpdateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createOrUpdateGroup,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.AdminID,
	)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AdminID,
	)
	return i, err
}

const deleteExpense = `-- name: DeleteExpense :one
DELETE FROM expense WHERE id = $1 RETURNING TRUE
`

func (q *Queries) DeleteExpense(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, deleteExpense, id)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const fetchExpense = `-- name: FetchExpense :one
SELECT id, description, amount, split, status, settled_by, created_by, payee, group_id, created_at, updated_at FROM expense WHERE id = $1 LIMIT 1
`

func (q *Queries) FetchExpense(ctx context.Context, id uuid.UUID) (Expense, error) {
	row := q.db.QueryRowContext(ctx, fetchExpense, id)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Amount,
		&i.Split,
		&i.Status,
		&i.SettledBy,
		&i.CreatedBy,
		&i.Payee,
		&i.GroupID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchExpenseByUserAndStatus = `-- name: FetchExpenseByUserAndStatus :many
SELECT e.id, e.description, e.amount, e.split, e.status, e.settled_by, e.created_by, e.payee, e.group_id, e.created_at, e.updated_at from expense_mapping em
JOIN expense e ON em.expense_id = e.id
where em.user_id = $1 AND e.status = $2
ORDER BY e.created_at DESC
LIMIT $3 OFFSET (($4 - 1) * $3)
`

type FetchExpenseByUserAndStatusParams struct {
	UserID  uuid.UUID
	Status  string
	Limit   int32
	Column4 interface{}
}

func (q *Queries) FetchExpenseByUserAndStatus(ctx context.Context, arg FetchExpenseByUserAndStatusParams) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, fetchExpenseByUserAndStatus,
		arg.UserID,
		arg.Status,
		arg.Limit,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Amount,
			&i.Split,
			&i.Status,
			&i.SettledBy,
			&i.CreatedBy,
			&i.Payee,
			&i.GroupID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExpenseCountByGroup = `-- name: FetchExpenseCountByGroup :one
SELECT COUNT(*) AS count FROM expense WHERE group_id = $1 AND group_id IS NOT NULL
`

func (q *Queries) FetchExpenseCountByGroup(ctx context.Context, groupID uuid.NullUUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, fetchExpenseCountByGroup, groupID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const fetchExpenseCountByGroupAndStatus = `-- name: FetchExpenseCountByGroupAndStatus :one
SELECT COUNT(*) AS count FROM expense WHERE group_id = $1 AND status = $2 AND group_id IS NOT NULL
`

type FetchExpenseCountByGroupAndStatusParams struct {
	GroupID uuid.NullUUID
	Status  string
}

func (q *Queries) FetchExpenseCountByGroupAndStatus(ctx context.Context, arg FetchExpenseCountByGroupAndStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, fetchExpenseCountByGroupAndStatus, arg.GroupID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const fetchExpenseCountByUserAndStatus = `-- name: FetchExpenseCountByUserAndStatus :one
SELECT COUNT(*) AS count FROM expense_mapping em
JOIN expense e ON em.expense_id = e.id
WHERE em.user_id = $1 AND e.status = $2
`

type FetchExpenseCountByUserAndStatusParams struct {
	UserID uuid.UUID
	Status string
}

func (q *Queries) FetchExpenseCountByUserAndStatus(ctx context.Context, arg FetchExpenseCountByUserAndStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, fetchExpenseCountByUserAndStatus, arg.UserID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const fetchGroupById = `-- name: FetchGroupById :one
SELECT id, name, description, admin_id FROM "group" WHERE id = $1 LIMIT 1
`

func (q *Queries) FetchGroupById(ctx context.Context, id uuid.UUID) (Group, error) {
	row := q.db.QueryRowContext(ctx, fetchGroupById, id)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AdminID,
	)
	return i, err
}

const fetchGroupExpenses = `-- name: FetchGroupExpenses :many
SELECT e.id, e.description, e.amount, e.split, e.status, e.settled_by, e.created_by, e.payee, e.group_id, e.created_at, e.updated_at
FROM expense e
WHERE e.group_id = $1
ORDER BY e.created_at DESC
LIMIT $3 OFFSET (($2 - 1) * $3)
`

type FetchGroupExpensesParams struct {
	GroupID uuid.NullUUID
	Column2 interface{}
	Limit   int32
}

func (q *Queries) FetchGroupExpenses(ctx context.Context, arg FetchGroupExpensesParams) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, fetchGroupExpenses, arg.GroupID, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Amount,
			&i.Split,
			&i.Status,
			&i.SettledBy,
			&i.CreatedBy,
			&i.Payee,
			&i.GroupID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchGroupExpensesByStatus = `-- name: FetchGroupExpensesByStatus :many
SELECT e.id, e.description, e.amount, e.split, e.status, e.settled_by, e.created_by, e.payee, e.group_id, e.created_at, e.updated_at 
FROM expense e
WHERE e.group_id = $1 AND e.status = $2
ORDER BY e.created_at DESC
LIMIT $4 OFFSET (($3 - 1) * $4)
`

type FetchGroupExpensesByStatusParams struct {
	GroupID uuid.NullUUID
	Status  string
	Column3 interface{}
	Limit   int32
}

func (q *Queries) FetchGroupExpensesByStatus(ctx context.Context, arg FetchGroupExpensesByStatusParams) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, fetchGroupExpensesByStatus,
		arg.GroupID,
		arg.Status,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Amount,
			&i.Split,
			&i.Status,
			&i.SettledBy,
			&i.CreatedBy,
			&i.Payee,
			&i.GroupID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchGroupMembers = `-- name: FetchGroupMembers :many
SELECT u.id, u.name, u.email, u.is_verified, u.password, u.created_at, u.updated_at FROM "users" u
JOIN group_members gm ON u.id = gm.user_id
WHERE gm.group_id = $1
`

func (q *Queries) FetchGroupMembers(ctx context.Context, groupID uuid.UUID) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchGroupMembers, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.IsVerified,
			&i.Password,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchGroupsByUser = `-- name: FetchGroupsByUser :many
SELECT g.id, g.name, g.description, g.admin_id FROM "group" g
JOIN group_members gm ON g.id = gm.group_id
WHERE gm.user_id = $1
`

func (q *Queries) FetchGroupsByUser(ctx context.Context, userID uuid.UUID) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, fetchGroupsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.AdminID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmail = `-- name: FetchUserByEmail :one
SELECT id, name, email, is_verified, password, created_at, updated_at FROM "users" WHERE email = $1
`

func (q *Queries) FetchUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, fetchUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.IsVerified,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchUserById = `-- name: FetchUserById :one
SELECT id, name, email, is_verified, password, created_at, updated_at FROM "users" WHERE id = $1 LIMIT 1
`

func (q *Queries) FetchUserById(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, fetchUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.IsVerified,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFriend = `-- name: GetFriend :one
SELECT u.id, u.name, u.email
FROM users u
JOIN friends f ON u.id = f.friend_id
WHERE (f.user_id = $1 AND f.friend_id = $2) OR (f.user_id = $2 AND f.friend_id = $1)
`

type GetFriendParams struct {
	UserID   uuid.UUID
	FriendID uuid.UUID
}

type GetFriendRow struct {
	ID    uuid.UUID
	Name  string
	Email string
}

func (q *Queries) GetFriend(ctx context.Context, arg GetFriendParams) (GetFriendRow, error) {
	row := q.db.QueryRowContext(ctx, getFriend, arg.UserID, arg.FriendID)
	var i GetFriendRow
	err := row.Scan(&i.ID, &i.Name, &i.Email)
	return i, err
}

const getFriends = `-- name: GetFriends :many

SELECT u.id, u.name, u.email, u.is_verified, u.created_at, u.updated_at
FROM users u
JOIN friends f ON u.id = f.friend_id
WHERE f.user_id = $1
`

type GetFriendsRow struct {
	ID         uuid.UUID
	Name       string
	Email      string
	IsVerified bool
	CreatedAt  sql.NullTime
	UpdatedAt  sql.NullTime
}

// Remove friendship in both directions
func (q *Queries) GetFriends(ctx context.Context, userID uuid.UUID) ([]GetFriendsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFriends, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendsRow
	for rows.Next() {
		var i GetFriendsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.IsVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertUser = `-- name: InsertUser :one
INSERT INTO "users" (id, name, email, is_verified, password, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, name, email, is_verified, password, created_at, updated_at
`

type InsertUserParams struct {
	ID         uuid.UUID
	Name       string
	Email      string
	IsVerified bool
	Password   string
	CreatedAt  sql.NullTime
	UpdatedAt  sql.NullTime
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, insertUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.IsVerified,
		arg.Password,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.IsVerified,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removeFriend = `-- name: RemoveFriend :one
DELETE FROM friends 
WHERE (user_id = $1 AND friend_id = $2) 
   OR (user_id = $1 AND friend_id = $2)
   RETURNING TRUE
`

type RemoveFriendParams struct {
	UserID   uuid.UUID
	FriendID uuid.UUID
}

func (q *Queries) RemoveFriend(ctx context.Context, arg RemoveFriendParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, removeFriend, arg.UserID, arg.FriendID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const removeUserFromGroup = `-- name: RemoveUserFromGroup :one
DELETE FROM group_members
WHERE user_id = $1 AND group_id = $2
RETURNING TRUE
`

type RemoveUserFromGroupParams struct {
	UserID  uuid.UUID
	GroupID uuid.UUID
}

func (q *Queries) RemoveUserFromGroup(ctx context.Context, arg RemoveUserFromGroupParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, removeUserFromGroup, arg.UserID, arg.GroupID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const removeUsersFromExpenseMapping = `-- name: RemoveUsersFromExpenseMapping :one
DELETE FROM expense_mapping
WHERE expense_id = $1 AND user_id = ANY($2::uuid[])
RETURNING TRUE
`

type RemoveUsersFromExpenseMappingParams struct {
	ExpenseID uuid.UUID
	Column2   []uuid.UUID
}

func (q *Queries) RemoveUsersFromExpenseMapping(ctx context.Context, arg RemoveUsersFromExpenseMappingParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, removeUsersFromExpenseMapping, arg.ExpenseID, pq.Array(arg.Column2))
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE "users"
SET name = $2, email = $3, is_verified = $4, password = $5, updated_at = NOW() AT TIME ZONE 'Asia/Kolkata'
WHERE id = $1
RETURNING id, name, email, is_verified, password, created_at, updated_at
`

type UpdateUserParams struct {
	ID         uuid.UUID
	Name       string
	Email      string
	IsVerified bool
	Password   string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.IsVerified,
		arg.Password,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.IsVerified,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
